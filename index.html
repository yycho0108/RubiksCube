<!DOCTYPE html>
<html lang="en">
<head>
    <title>Rubiks Cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>
<script src="https://code.jquery.com/jquery-2.2.4.js" integrity="sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI="
        crossorigin="anonymous"></script>
<script src="three.min.js"></script>

<script>

    var container, stats;
    var camera, scene, raycaster, renderer;
    var outScene;
    var rubiksCube;

    var mouse = new THREE.Vector3(), INTERSECTED;

    var xaxis = new THREE.Vector3(1, 0, 0);
    var yaxis = new THREE.Vector3(0, 1, 0);
    var zaxis = new THREE.Vector3(0, 0, 1);

    var radius = 128, theta = 45, phi = 45;

    var rotateScene = false;
    var rotateCube = false;

    var src = new THREE.Vector3();
    var sel = new THREE.Vector3();
    var orig;

    function similar(a,b,threshold) {
        if(threshold == undefined || threshold == null){
            threshold = 0.01;
        }
        return Math.abs(a - b) < threshold;
    }

    function mod_pos(a,b){
        return ((a%b)+b)%b;
    }
    function contain(x,a,b){

        if(a>b){
            [a,b] = [b,a]; //swap
        }

        if(x < a){
            return a;
        }else if (b < x){
            return b;
        }

        return x;
    }
    $(document).ready(function () {
        init();
        animate();
    });

    function cubeMaterial(x, y, z) {
        var colors = [0xff0000, 0x00ff00, 0x0000ff, 0x00ffff, 0xff00ff, 0xffff00];
        var materials = new Array(6);

        /* COLORING */
        for (var i = 0; i < 6; ++i) {
            var color;
            //R-L-U-D-F-B
            if ((i == 0 && x == 1) ||
                    (i == 1 && x == -1) ||
                    (i == 2 && y == 1) ||
                    (i == 3 && y == -1) ||
                    (i == 4 && z == 1) ||
                    (i == 5 && z == -1)
            )
                color = colors[i];
            else
                color = 0x000000;

            materials[i] = new THREE.MeshPhongMaterial({
                color: color,
                shading: THREE.FlatShading,
                overdraw: true
            });
        }

        return new THREE.MeshFaceMaterial(materials);
    }

    /* RubiksCube */
    function RubiksCube(size) {
        this.size = size;
        this.cube = new THREE.Group();
        this.cubes = new Array(3);

        this.active = [];

        this.pivotAxis = '-'; //indicates no lock
        this.pivotDir = 0; //indicates no lock
        this.returning = false;

        for (var x = -1; x <= 1; ++x) {
            this.cubes[x + 1] = new Array(3);
            for (var y = -1; y <= 1; ++y) {
                this.cubes[x + 1][y + 1] = new Array(3);
                for (var z = -1; z <= 1; ++z) {

                    var material = cubeMaterial(x, y, z);
                    var geometry = new THREE.BoxGeometry(size, size, size);

                    var cube_one = new THREE.Mesh(geometry, material);
                    cube_one.position.x = x * size * 1.25;
                    cube_one.position.y = y * size * 1.25;
                    cube_one.position.z = z * size * 1.25;

                    cube_one.edgesHelper = new THREE.EdgesHelper(cube_one, 0xffffff);
                    cube_one.edgesHelper.material.linewidth = 2;

                    scene.add(cube_one);
                    scene.add(cube_one.edgesHelper);

                    this.cubes[x + 1][y + 1][z + 1] = cube_one;
                    //save reference
                }
            }
        }
    }
    RubiksCube.prototype.lock = function (sel, axis,dir) {
        this.pivotAxis = axis;
        this.pivotDir = dir;

        var x = (axis == 'x')?sel.x:0;
        var y = (axis == 'y')?sel.y:0;
        var z = (axis == 'z')?sel.z:0;

        var cube;

        this.pivot = this.cubes[x+1][y+1][z+1];

        console.log(this.pivot.position[axis]);

        for(x=-1;x<=1;++x){
            for(y=-1;y<=1;++y){
                for(z=-1;z<=1;++z){
                    cube = this.cubes[x+1][y+1][z+1];

                    if(similar(cube.position[axis], this.pivot.position[axis], 0.3)){
                        this.active.push(cube);
                        if(cube != this.pivot){
                            THREE.SceneUtils.attach(cube, scene, this.pivot);
                        }
                    }
                }
            }
        }
//
//
//        switch (axis) {
//            case 'x':
//                this.pivot = this.cubes[sel.x+1][0+1][0+1];
//                for (y = -1; y <= 1; ++y) {
//                    for (z = -1; z <= 1; ++z) {
//                        cube = this.cubes[sel.x + 1][y + 1][z + 1];
//                        this.active.push(cube);
//                        if(cube != this.pivot){
//                            THREE.SceneUtils.attach(cube, this.cube, this.pivot);
//                        }
//                    }
//                }
//                break;
//            case 'y':
//                this.pivot = this.cubes[0+1][sel.y+1][0+1];
//                for (x = -1; x <= 1; ++x) {
//                    for (z = -1; z <= 1; ++z) {
//                        cube = this.cubes[x + 1][sel.y + 1][z + 1];
//                        this.active.push(cube);
//                        if(cube != this.pivot){
//                            THREE.SceneUtils.attach(cube, this.cube, this.pivot);
//                        }
//                    }
//                }
//                break;
//            case 'z':
//                this.pivot = this.cubes[0+1][0+1][sel.z+1];
//                for (x = -1; x <= 1; ++x) {
//                    for (y = -1; y <= 1; ++y) {
//                        cube = this.cubes[x + 1][y + 1][sel.z + 1];
//                        this.active.push(cube);
//                        if(cube != this.pivot){
//                            THREE.SceneUtils.attach(cube, this.cube, this.pivot);
//                        }
//                    }
//                }
//                break;
//        }
    };



    RubiksCube.prototype.release = function(){

        console.log(this.active.length);

        for (i in this.active){
            //this.active[i].updateMatrixWorld();
            if(this.active[i] != this.pivot){
                THREE.SceneUtils.detach(this.active[i],this.pivot,scene);
            }
        }

        this.pivotAxis = '-';
        this.pivotDir = 0;
        this.active = [];
        this.returning = false;

        this.reIndex();
    };

    RubiksCube.prototype.snap = function () {
        var angle = mod_pos(this.pivot.rotation[this.pivotAxis], Math.PI*2);

        this.pivotDir = contain(this.target - angle, -0.5, 0.5);
        this.rotateOnPivot();
        angle = mod_pos(this.pivot.rotation[this.pivotAxis], Math.PI*2);

        if(similar(angle,this.target, 0.01)){
            this.returning = false;
            console.log(this.returning);
            this.release();
        }
    };

    RubiksCube.prototype.startReturn = function(){
        var angle = mod_pos(this.pivot.rotation[this.pivotAxis], Math.PI*2);
        var quad = Math.round(angle / (Math.PI/2));
        this.target = ((Math.PI/2) * quad);
        this.returning = !similar(angle,this.target);
        //this.return();
    };

    RubiksCube.prototype.rotateOnPivot = function () {
        this.pivot.rotation[this.pivotAxis] += (this.pivotDir * 0.1);
    };

    RubiksCube.prototype.reIndex = function () {
        // finish rotation

    };

    function addLight(scene) {
        var light = new THREE.DirectionalLight(0xffffff, 0.3);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.001));
    }

    function addCube(scene) {
        var size = 20;
        rubiksCube = new RubiksCube(size);
        scene.add(rubiksCube.cube);
    }

    function addCamera(scene) {

    }

    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        scene = new THREE.Scene();
        outScene = new THREE.Scene();

        addLight(scene);
        addCube(scene);

        raycaster = new THREE.Raycaster();

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        container.appendChild(renderer.domElement);

        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);

        window.addEventListener('resize', onWindowResize, false);


        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);

        //initialize camera
        camera.position.x = radius * Math.sin(theta * Math.PI / 360)
                * Math.cos(phi * Math.PI / 360);
        camera.position.y = radius * Math.sin(phi * Math.PI / 360);
        camera.position.z = radius * Math.cos(theta * Math.PI / 360)
                * Math.cos(phi * Math.PI / 360);
        camera.updateMatrix();
        camera.lookAt(scene.position);

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseUp(event) {
        event.preventDefault();
        rotateScene = false;

        // finish rotating cube
        if (rotateCube) {
            rubiksCube.startReturn();
        }

        rotateCube = false;

    }

    function onMouseDown(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
        mouse.z = 0.0;

        src = mouse.clone();

        rotateScene = (event.buttons & 4); //middle button

        rotateCube = (event.buttons & 1); //left button

        if (rotateCube) {
            //find the selected sub-cube
            console.log(rubiksCube.cube.children.length);
            var intersects = raycaster.intersectObjects(scene.children);


            if (intersects.length > 0) {
                console.log(intersects[0].face);
                orig = new THREE.Vector3(mouse.x, mouse.y, 0.0).unproject(camera); //--> real coordinates
                console.log(orig);

                for (var x = -1; x <= 1; ++x) {
                    for (var y = -1; y <= 1; ++y) {
                        for (var z = -1; z <= 1; ++z) {
                            if (rubiksCube.cubes[x + 1][y + 1][z + 1] == intersects[0].object) {
                                sel.set(x, y, z);
                            }
                        }
                    }
                }
            }
        }
    }

    function rotateAroundWorldAxis(object, axis, radians) {
        var rotWorldMatrix = new THREE.Matrix4();
        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
        object.applyMatrix(rotWorldMatrix);
    }

    function onMouseMove(event) {
        // currently implementing rotating the cube faces

        event.preventDefault();
        var newX = ( event.clientX / window.innerWidth ) * 2 - 1;
        var newY = -( event.clientY / window.innerHeight ) * 2 + 1;

        var dx = newX - mouse.x;
        var dy = newY - mouse.y;

        if (rotateScene) {

            theta -= ( dx * 100);
            phi -= ( dy * 100);

            //phi = Math.min( 180, Math.max( 0, phi ) );
            camera.position.x = radius * Math.sin(theta * Math.PI / 360)
                    * Math.cos(phi * Math.PI / 360);
            camera.position.y = radius * Math.sin(phi * Math.PI / 360);
            camera.position.z = radius * Math.cos(theta * Math.PI / 360)
                    * Math.cos(phi * Math.PI / 360);
            camera.updateMatrix();
            camera.lookAt(scene.position);
            camera.updateMatrixWorld();
        }
        console.log(rotateCube);

        if (rotateCube) {

            var xdst = (orig.clone().add(xaxis)).project(camera).sub(mouse);
            var ydst = (orig.clone().add(yaxis)).project(camera).sub(mouse);
            var zdst = (orig.clone().add(zaxis)).project(camera).sub(mouse);
            //console.log(xdst, ydst, zdst);
            var dv = new THREE.Vector3(newX, newY, 0.0).sub(src);

            switch (rubiksCube.pivotAxis) {
                case '-':
                    if (dv.length() > 0.05) { //arbitrary threshold to determine direction
                        var xProb = xdst.dot(dv);
                        var yProb = ydst.dot(dv);
                        var zProb = zdst.dot(dv);
                        var maxProb = Math.min(Math.abs(xProb), Math.abs(yProb), Math.abs(zProb)); //min since orthogonal axis...
                        console.log(xProb, yProb, zProb);

                        var axis;
                        var dir;

                        if (Math.abs(xProb) == maxProb) {
                            axis = 'x';
                            dir = xProb >= 0? 1: -1;
                        } else if (yProb == maxProb) {
                            axis = 'y';
                            dir = yProb >= 0? 1: -1;
                        } else {
                            axis = 'z';
                            dir = zProb >= 0? 1: -1;
                        }

                        rubiksCube.lock(sel, axis, dir);
                    }
                    break;
                default:
                    rubiksCube.rotateOnPivot();
                    break;
            }

        }

        mouse.x = newX;
        mouse.y = newY;
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        //console.log(rubiksCube.returning);
        if(rubiksCube.returning){
            rubiksCube.snap();
        }
        raycaster.setFromCamera(mouse, camera);
        renderer.render(scene, camera);
    }

</script>

</body>
</html>