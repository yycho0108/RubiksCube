<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - interactive cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script src="three.min.js"></script>

<script>

    var container, stats;
    var camera, scene, raycaster, renderer;
    var outScene;

    var cube;

    var mouse = new THREE.Vector2(), INTERSECTED;
    var radius = 128, theta = 45, phi = 45;

    var rotateScene = false;
    var rotateCube = false;
    var srcX, srcY;
    var selX, selY, selZ;
    var orig;

    init();
    animate();

    function addCube() {
        var size = 20;

        var colors = [0xff0000, 0x00ff00, 0x0000ff, 0x00ffff, 0xff00ff, 0xffff00];

        cube = new Array(3);
        for (var x = -1; x <= 1; ++x) {
            cube[x + 1] = new Array(3);
            for (var y = -1; y <= 1; ++y) {
                cube[x + 1][y + 1] = new Array(3);
                for (var z = -1; z <= 1; ++z) {
                    var materials = new Array(6);

                    for (var i = 0; i < 6; ++i) {

                        //R-L-U-D-F-B
                        if ((i == 0 && x == 1) ||
                                (i == 1 && x == -1) ||
                                (i == 2 && y == 1) ||
                                (i == 3 && y == -1) ||
                                (i == 4 && z == 1) ||
                                (i == 5 && z == -1)
                        )
                            color = colors[i];
                        else
                            color = 0x000000;

                        materials[i] = new THREE.MeshPhongMaterial({
                            color: color,
                            shading: THREE.FlatShading,
                            overdraw: true
                        });
                    }
                    var material = new THREE.MeshFaceMaterial(materials);

                    var geometry = new THREE.BoxGeometry(size, size, size);
                    var object = new THREE.Mesh(geometry, material);
                    object.position.x = x * size * 1.25;
                    object.position.y = y * size * 1.25;
                    object.position.z = z * size * 1.25;
                    scene.add(object);

                    //save reference
                    cube[x + 1][y + 1][z + 1] = object;
                }
            }
        }

    }

    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        scene = new THREE.Scene();
        outScene = new THREE.Scene();

        var light = new THREE.DirectionalLight(0xffffff, 0.3);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.001));

        addCube();

        raycaster = new THREE.Raycaster();

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        container.appendChild(renderer.domElement);

        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);

        window.addEventListener('resize', onWindowResize, false);


        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);

        //initialize camera
        camera.position.x = radius * Math.sin(theta * Math.PI / 360)
                * Math.cos(phi * Math.PI / 360);
        camera.position.y = radius * Math.sin(phi * Math.PI / 360);
        camera.position.z = radius * Math.cos(theta * Math.PI / 360)
                * Math.cos(phi * Math.PI / 360);
        camera.updateMatrix();
        camera.lookAt(scene.position);

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onMouseUp(event) {
        event.preventDefault();
        rotateScene = false;
        rotateCube = false;
        //if rotateCube is true ... snap back rotation
    }

    function onMouseDown(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;

        srcX = mouse.x;
        scrY = mouse.y;

        rotateScene = (event.buttons & 4);
        rotateCube = (event.buttons & 1);

        if(rotateCube){
            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {

                orig = new THREE.Vector3(mouse.x,mouse.y,0.0).unproject(camera); //--> real coordinates
                console.log(orig);

                for(var x = -1; x <= 1; ++x){
                    for(var y = -1; y <= 1; ++y){
                        for(var z = -1; z <= 1; ++z){
                            if(cube[x+1][y+1][z+1] == intersects[0].object){
                                selX = x; selY = y; selZ = z;
                                console.log(selX,selY,selZ);
                            }
                        }
                    }
                }
                //intersects[0].object.rotateX(1.0);
            }
        }
    }
    function onMouseMove(event) {
        // currently implementing rotating the cube faces

        event.preventDefault();
        var newX = ( event.clientX / window.innerWidth ) * 2 - 1;
        var newY = -( event.clientY / window.innerHeight ) * 2 + 1;

        var dx = newX - mouse.x;
        var dy = newY - mouse.y;

        if (rotateScene) {

            theta -= ( dx * 100);
            phi -= ( dy * 100);

            //phi = Math.min( 180, Math.max( 0, phi ) );
            camera.position.x = radius * Math.sin(theta * Math.PI / 360)
                    * Math.cos(phi * Math.PI / 360);
            camera.position.y = radius * Math.sin(phi * Math.PI / 360);
            camera.position.z = radius * Math.cos(theta * Math.PI / 360)
                    * Math.cos(phi * Math.PI / 360);
            camera.updateMatrix();
            camera.lookAt(scene.position);
            camera.updateMatrixWorld();
        }
        if(rotateCube){
            var xdst = (orig.clone().add(new THREE.Vector3(1,0,0))).project(camera);
            var ydst = (orig.clone().add(new THREE.Vector3(0,1,0))).project(camera);
            var zdst = (orig.clone().add(new THREE.Vector3(0,0,1))).project(camera);
            console.log(xdst,ydst,zdst);
            dv = new THREE.Vector3(dx,dy,0);
            var xProb = xdst.dot(dv);
            var yProb = ydst.dot(dv);
            var zProb = zdst.dot(dv);
            var sum = Math.abs(xProb+yProb+zProb);
            console.log(xProb/sum,yProb/sum,zProb/sum);

            //if dx,dy > threshold ...

        }

        mouse.x = newX;
        mouse.y = newY;
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        //cube[0][0][0].rotateX(1.1);


        // find intersections

        raycaster.setFromCamera(mouse, camera);


        renderer.render(scene, camera);

    }

</script>

</body>
</html>